# import 문 추가하기 (교재에 없음)

# 시각화를 하기 위해 최적의 C(비용)와, 최적의 C를 비교하기 위한 다른 C를 후보로 저장
    # 리스트(배열) 선언
    # 최적 C의 1/100배
    # 최적의 C -> 위에서 0.1이었음.
    # 최적 C의 100배

# 시각화를 하기 위해 최적의 gamma와, 최적의 gamma를 비교하기 위한 다른 gamma를 후보로 저장

    # 최적 gamma의 1/100배
    # 최적의 감마 -> 위에서 1이었음.
    # 최적 gamma의 100배

# 3점슛과 블로킹 횟수로 학습

# 농구선수 포지션을 학습 모듈의 분류값으로 사용
      # 주의! 1차원 리스트(배열)임. 교재에서와 같이 .tolist() 사용 안 해도 됨.

# 시각화를 위해 센터(C)와 슈팅가드(SG)를 숫자로 표현

        # for, if문 (들여쓰기 조심: 4칸, 8칸)

           # 센터인 경우 0으로 저장

           # 슈팅가드인 경우 1로 저장

# 각각의 파라미터에 해당하는 SVM 모델을 실행하여 classifiers에 저장

      # 중첩 for문 (들여쓰기 조심: 4칸, 8칸)

          # C와 gamma 값으로 SVM 설정
          # SVM 학습 실행
          # C와 gamma, SVM 실행 결과를 classifiers에 저장

# 각 모델을 시각화        
        # 전체 그림 크기 지정, 즉 18, 18 사이즈로 차트를 구성

                                  # linspace(시작, 끝, 전체 점의 수). 스펠링 주의!! lin에 e가 없음.
# 위 문장 실행 후, xx = [[0, 0.04, 0.08, ... , 1, 1.04, ... , 2, ... , 3, ... , 4],
#                                [0, 0.04, 0.08, ... , 1, 1.04, ... , 2, ... , 3, ... , 4],
#                                                           .....................
#                                [0, 0.04, 0.08, ... , 1, 1.04, ... , 2, ... , 3, ... , 4]]  <= 100줄
#                       yy = [[     0,      0,      0, ... ,    0],
#                                [0.04, 0.04, 0.04, ... ,0.04],
#                                [0.08, 0.08, 0.08, ... ,0.08],
#                                          .....................
#                                [     4,      4,      4, ... ,    4]]   <= 100줄

# 각각의 모델들에 대한 결정 경계 함수를 적용하여 함께 시각화
        # enumerate(a) : a의 각 경우를 k에 0부터 저장(아래 예 참조)
        # ravel() : 1차원 리스트(배열)로 만들기
        # np.c_[ ] : [ ]의 두 요소 값으로 2차원 리스트 만들기
    # (예) for k, name in enumerate (['body', 'foo', 'bar']):
    #            print(k, name)
    #       ==> 실행 결과 : 0 body
    #                               1 foo
    #                               2 bar        
    # clf_gp.decision_function : clf의 값을 사용하여 경계면을 찾아내는 함수. 경계면이면 0, 한쪽 클래스는 음수,
    #                                    나머지 한쪽 클래스는 양수로 값을 출력함.
    # xx.shape : xx의 모양(여기서는 100x100)
    # Z.reshape(xx.shape) : Z를 (xx.shape)의 모양(즉, 여기서는 100x100)으로 2차원 리스트로 만들어줌. 
    #                                 이거를 하는 이유는 decision_function의 결과가 저장된 Z는 1차원 리스트로 저장되어 있음. 
    #                                 이거를 2차원 그래프로 나타내기 위해 reshape 명령을 사용해서 2차원 리스트로 만들어 주는 것임.
    
    # 최적의 모델을 포함한 다른 파라미터로 학습된 모델들을 함께 시각화
                    # subplot(3,3,1) : 3x3 배열 중 첫 번째에 그리기
    
                                                    #예: log10(0.01) = log10(10^-2) = -2

    # 결정 경계영역과 결정경계선 그리기
               # xx와 yy 좌표에 대해 Z값으로 색상 그리기
    # cmap에서 지정한 색상에 따라 Z 값으로 색상을 그리는데, cmap이 Rd(Red), Bu(Blue) 순이므로 Z가 음수이면 빨간색,
    # 양수이면 파란색, 0이면 하얀색으로 색상을 그리게 됨. 그런데 이대로 그림을 그리면 색상이 반대로 표시되어 정상적으로 
    # 색상 표시를 하기 위해 Z에 마이너스를 붙인 것임.
    
    # 3점슛과 블로킹 값을 이용하여 센터와 슈팅가드 점 찍기
                          # edgecolors: 테두리 색, 'k'는 'Black'.
    # 3P(x축)와 BLK(y축)의 좌표에 c값에 따른 색상으로 점을 찍음. cmap에서 RdBu_r는 Rd(Red), Bu(Blue) 순서를 뒤집으란
    # 얘기임. 즉, 앞쪽이 Blue, 그 다음이 Red가 됨. 그런데 c 값이 위에서 센터는 0, 슈팅가드는 1로 지정되어 있으므로,
    # 결국 센터는 파란색 점으로, 슈팅가드는 빨간색 점으로 찍히게 됨.

# => AttributeError: 'SVC' object has no attribute 'best_params_'라는 에러 메시지가 뜨면
# => "런타임 > 모두 실행" 또는 Ctrl+F9을 눌러 처음부터 다시 실행할 것. 