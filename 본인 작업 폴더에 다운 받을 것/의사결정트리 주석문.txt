       # 사용자 정의 함수(clf: 의사결정트리 객체, X: 입력, y: 출력 레이블)

    # 차트에 모든 학습 데이터가 보이도록 최대, 최소 값의 범위를 약간의 여유 값으로 설정
        # 여기서 x는 입력이 아님. x축을 의미함. 

        # 여기서 y는 레이블(정답)이 아님. y축을 의미함. 
    
    
    # 파라미터 설정
       # 이 경우 n_classes에는 4가 저장됨(강북~강서)
       # red, yellow, white, blue로 색상 설정
       # 구간 간격


                                  # np.arange(시작, 끝, 값 사이의 간격) : 시작부터 끝 사이의 간격이 일정한 값 반환
    # 학습 데이터의 경우, 이 문장 실행 후, xx = [[126.8395, 126.8405, ...... , 127.1595, 127.1605],  <= 우측으로 증가
    #                                                           [126.8395, 126.8405, ...... , 127.1595, 127.1605],
    #                                                                                     .....................
    #                                                          [126.8395, 126.8405, ...... , 127.1595, 127.1605]] 
    #                                                 yy = [[37.4419, 37.4419, ...... , 37.4419, 37.4419],  <= 아래로 증가
    #                                                          [37.4429, 37.4429, ...... , 37.4429, 37.4429],
    #                                                          [37.4439, 37.4439, ...... , 37.4439, 37.4439],
    #                                                                 .....................
    #                                                          [37.6779, 37.6779, ...... , 37.6779, 37.6779]]   

        # ravel() : 1차원 리스트(배열)로 만들기, 
        # np.c_[ ] : [ ]의 두 요소 값으로 2차원 리스트 만들기
    # xx.shape : xx의 개수
    # Z.reshape(xx.shape) : Z를 ()의 개수만큼 2차원 리스트로 만들어줌. 이거를 하는 이유는 clf.predict의 결과가 저장된 Z는 
    #                                  1차원 리스트로 저장되어 있음. 이거를 2차원 그래프로 나타내기 위해 reshape 명령을 사용해서 
    #                                  2차원 리스트로 만들어 주는 것임.
    
    # Z 값(예측 결과)에 따른 색상을 그림에 표시

                     # x좌표, y좌표, Z는 그려질 예측 데이터(즉, 예측 결과 강북, 강동, 강남, 강서를 나타내는 0~3).              
                     # cmap의 RdYlBu 색상에서 노란색(Yl)과 파란색(Bu) 사이에 흰색(White)이 자동 설정됨.
                     # 색상은 위 11번 줄의 plot_colors와 순서가 동일하게 설정.
    
    # 학습 데이터를 차트에 점으로 표시
    # zip(a, b) : a와 b를 합쳐서 순서대로 튜플형으로 반환. (0, Red), (1, Yellow), (2, White), (3, Blue)

           # y(출력 레이블) 리스트에서 i가 있는 위치 찾기
            # i의 레이블 이름 저장. 즉 강북~강서
                         # s: 크기

       # 차트 제목
         # 차트 기호 설명 (범례(legend) 만들기)
                # bbox_to_anchor : 차트에서의 범례 상대적 위치, (0,0): 좌측 하단, (0,1): 좌측 상단, (1,0): 우측 하단, (1,1): 우측 상단
                # loc : legend(범례) 박스의 기준점. 1: upper right, 2: upper left, 3: lower left, 4: lower right, 5: right, 6: center left
                #                                               7: center right, 8: lower center, 9: upper center, 10: center
                # borderaxespad : legend(범례) 박스와 기준 축(상단 가로선) 사이의 간격, 0으로 해야 기준축에 딱 붙게 됨.
    
      # x축의 이름과 폰트 크기 설정
      # y축의 이름과 폰트 크기 설정
      # 차트 크기 설정
      # x축 눈금 숫자의 크기 설정
      # y축 눈금 숫자의 크기 설정
      # 차트 그리기
    
      # 함수 실행
# 결과: 아무 파라미터 설정 없이 의사결정트리 학습을 하면 다음 그림과 같이 과대적합(Overfitting) 발생